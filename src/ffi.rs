/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type Clp_Simplex = ::std::os::raw::c_void;
pub type clp_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Clp_Simplex,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type Sbb_Model = ::std::os::raw::c_void;
pub type Cbc_Model = ::std::os::raw::c_void;
#[doc = " typedef for user call back."]
#[doc = "The cvec are constructed so don't need to be const"]
pub type sbb_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Sbb_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
pub type cbc_callback = ::std::option::Option<
    unsafe extern "C" fn(
        model: *mut Cbc_Model,
        msgno: ::std::os::raw::c_int,
        ndouble: ::std::os::raw::c_int,
        dvec: *const f64,
        nint: ::std::os::raw::c_int,
        ivec: *const ::std::os::raw::c_int,
        nchar: ::std::os::raw::c_int,
        cvec: *mut *mut ::std::os::raw::c_char,
    ),
>;
#[doc = " typedef for cbc cut callback osiSolver needs to be an OsiSolverInterface object,"]
#[doc = " osiCuts is an OsiCuts object and appdata is a pointer that will be passed to the cut"]
#[doc = " generation, you can use it to point to a data structure with information about the original problem,"]
#[doc = " for instance"]
pub type cbc_cut_callback = ::std::option::Option<
    unsafe extern "C" fn(
        osiSolver: *mut ::std::os::raw::c_void,
        osiCuts: *mut ::std::os::raw::c_void,
        appdata: *mut ::std::os::raw::c_void,
    ),
>;
pub type CoinBigIndex = ::std::os::raw::c_int;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
extern "C" {
    #[doc = " Current version of Cbc"]
    #[link_name = "\u{1}_Cbc_getVersion"]
    pub fn Cbc_getVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Creates an empty problem"]
    #[link_name = "\u{1}_Cbc_newModel"]
    pub fn Cbc_newModel() -> *mut Cbc_Model;
}
extern "C" {
    #[doc = " @brief Sets problem name."]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param array string with problem name"]
    #[link_name = "\u{1}_Cbc_setProblemName"]
    pub fn Cbc_setProblemName(
        model: *mut Cbc_Model,
        array: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates a new column"]
    #[doc = ""]
    #[doc = " Creates a new column (variable)"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param name variable name"]
    #[doc = " @param lb column lower bound"]
    #[doc = " @param ub column upper bound"]
    #[doc = " @param obj objective function coefficient"]
    #[doc = " @param isInteger 1 if variable is integral, 0 otherwise"]
    #[doc = " @param nz number of rows (constraints) where this column appears, can be 0 if constraints will be added later"]
    #[doc = " @param rows index of rows where this column appears, NULL if rows will be added later"]
    #[doc = " @param coefs coefficients that this column appears in its rows, NULL if rows will be added later"]
    #[link_name = "\u{1}_Cbc_addCol"]
    pub fn Cbc_addCol(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        lb: f64,
        ub: f64,
        obj: f64,
        isInteger: ::std::os::raw::c_char,
        nz: ::std::os::raw::c_int,
        rows: *mut ::std::os::raw::c_int,
        coefs: *mut f64,
    );
}
extern "C" {
    #[doc = " @brief Adds a new row"]
    #[doc = ""]
    #[doc = "  Adds a new row (linear constraint) to the problem"]
    #[doc = ""]
    #[doc = "  @param model problem object"]
    #[doc = "  @param name constraint name"]
    #[doc = "  @param nz number of variables with non-zero coefficients in this row"]
    #[doc = "  @param cols index of variables that appear in this row"]
    #[doc = "  @param coefs cofficients that that variables appear"]
    #[doc = "  @param sense constraint sense: L if <=, G if >=, E if =, R if ranged and N if free"]
    #[doc = "  @param rhs right hand size"]
    #[link_name = "\u{1}_Cbc_addRow"]
    pub fn Cbc_addRow(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        nz: ::std::os::raw::c_int,
        cols: *const ::std::os::raw::c_int,
        coefs: *const f64,
        sense: ::std::os::raw::c_char,
        rhs: f64,
    );
}
extern "C" {
    #[doc = " @brief Add SOS constraints to the model using row-order matrix"]
    #[link_name = "\u{1}_Cbc_addSOS"]
    pub fn Cbc_addSOS(
        model: *mut Cbc_Model,
        numRows: ::std::os::raw::c_int,
        rowStarts: *const ::std::os::raw::c_int,
        colIndices: *const ::std::os::raw::c_int,
        weights: *const f64,
        type_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Loads a problem (the constraints on the"]
    #[doc = "rows are given by lower and upper bounds). If a pointer is NULL then the"]
    #[doc = "following values are the default:"]
    #[doc = "<ul>"]
    #[doc = "<li> <code>colub</code>: all columns have upper bound infinity"]
    #[doc = "<li> <code>collb</code>: all columns have lower bound 0"]
    #[doc = "<li> <code>rowub</code>: all rows have upper bound infinity"]
    #[doc = "<li> <code>rowlb</code>: all rows have lower bound -infinity"]
    #[doc = "<li> <code>obj</code>: all variables have 0 objective coefficient"]
    #[doc = "</ul>"]
    #[doc = ""]
    #[doc = "The constraint matrix is"]
    #[doc = "given in standard compressed sparse column (without gaps)."]
    #[doc = "<ul>"]
    #[doc = "<li> <code>start[i]</code> stores the starting index of the ith column"]
    #[doc = "<li> <code>index[k]</code> stores the row index of the kth nonzero element"]
    #[doc = "<li> <code>value[k]</code> stores the coefficient of the kth nonzero element"]
    #[doc = "</ul>"]
    #[link_name = "\u{1}_Cbc_loadProblem"]
    pub fn Cbc_loadProblem(
        model: *mut Cbc_Model,
        numcols: ::std::os::raw::c_int,
        numrows: ::std::os::raw::c_int,
        start: *const CoinBigIndex,
        index: *const ::std::os::raw::c_int,
        value: *const f64,
        collb: *const f64,
        colub: *const f64,
        obj: *const f64,
        rowlb: *const f64,
        rowub: *const f64,
    );
}
extern "C" {
    #[doc = " @brief Set the name of a column"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param iColumn column index"]
    #[doc = " @param column name"]
    #[link_name = "\u{1}_Cbc_setColName"]
    pub fn Cbc_setColName(
        model: *mut Cbc_Model,
        iColumn: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Set the name of a row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param iRow row index"]
    #[doc = " @param name row name"]
    #[link_name = "\u{1}_Cbc_setRowName"]
    pub fn Cbc_setRowName(
        model: *mut Cbc_Model,
        iRow: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Sets optimization direction"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param sense: direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)"]
    #[link_name = "\u{1}_Cbc_setObjSense"]
    pub fn Cbc_setObjSense(model: *mut Cbc_Model, sense: f64);
}
extern "C" {
    #[doc = " @brief Set the lower bound of a single constraint"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param index row index"]
    #[doc = " @param value new row lower bound"]
    #[link_name = "\u{1}_Cbc_setRowLower"]
    pub fn Cbc_setRowLower(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    #[doc = " @brief  Set the upper bound of a single constraint"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param index row index"]
    #[doc = " @param value new row upper bound"]
    #[link_name = "\u{1}_Cbc_setRowUpper"]
    pub fn Cbc_setRowUpper(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    #[doc = " @brief Set the objective coefficient of a single variable"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param index variable index"]
    #[doc = " @param value new objective function coefficient for this variable"]
    #[link_name = "\u{1}_Cbc_setObjCoeff"]
    pub fn Cbc_setObjCoeff(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    #[doc = " @brief Set the lower bound of a single variable"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param index variable index"]
    #[doc = " @param value variable lower bound"]
    #[link_name = "\u{1}_Cbc_setColLower"]
    pub fn Cbc_setColLower(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    #[doc = " @brief Set the upper bound of a single variable"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param index variable index"]
    #[doc = " @param value new variable upper bound"]
    #[link_name = "\u{1}_Cbc_setColUpper"]
    pub fn Cbc_setColUpper(model: *mut Cbc_Model, index: ::std::os::raw::c_int, value: f64);
}
extern "C" {
    #[doc = " @brief Set this variable to be continuous"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param iColumn column index"]
    #[link_name = "\u{1}_Cbc_setContinuous"]
    pub fn Cbc_setContinuous(model: *mut Cbc_Model, iColumn: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Set this variable to be integer"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param iColumn column index"]
    #[link_name = "\u{1}_Cbc_setInteger"]
    pub fn Cbc_setInteger(model: *mut Cbc_Model, iColumn: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Cbc_Model destructor"]
    #[link_name = "\u{1}_Cbc_deleteModel"]
    pub fn Cbc_deleteModel(model: *mut Cbc_Model);
}
extern "C" {
    #[doc = " @brief Enter initial feasible solution"]
    #[doc = ""]
    #[doc = " Enter an initial feasible solution. Only the non-zero main"]
    #[doc = " binary/integer decision variables need to be informed."]
    #[doc = " Auxiliary and/or continuous variables are computed"]
    #[doc = " automatically."]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param count number of variables"]
    #[doc = " @param colNames names of variables"]
    #[doc = " @param colValues variable values"]
    #[doc = ""]
    #[link_name = "\u{1}_Cbc_setMIPStart"]
    pub fn Cbc_setMIPStart(
        model: *mut Cbc_Model,
        count: ::std::os::raw::c_int,
        colNames: *mut *const ::std::os::raw::c_char,
        colValues: *const f64,
    );
}
extern "C" {
    #[doc = " @brief Enter initial feasible solution"]
    #[doc = ""]
    #[doc = " Enter an initial feasible solution. Only the non-zero main"]
    #[doc = " binary/integer decision variables need to be informed."]
    #[doc = " Auxiliary and/or continuous variables are computed"]
    #[doc = " automatically. Same as setMIPStart but using variable indexes."]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param count number of variables"]
    #[doc = " @param colIdxs indexes of variables"]
    #[doc = " @param colValues variable values"]
    #[doc = ""]
    #[link_name = "\u{1}_Cbc_setMIPStartI"]
    pub fn Cbc_setMIPStartI(
        model: *mut Cbc_Model,
        count: ::std::os::raw::c_int,
        colIdxs: *const ::std::os::raw::c_int,
        colValues: *const f64,
    );
}
extern "C" {
    #[doc = " @brief Creates a copy of the current model"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return model copy"]
    #[link_name = "\u{1}_Cbc_clone"]
    pub fn Cbc_clone(model: *mut Cbc_Model) -> *mut Cbc_Model;
}
extern "C" {
    #[doc = " @brief Queries problem name"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param maxNumberCharacters space in string array"]
    #[doc = " @param array string where problem name will be saved"]
    #[link_name = "\u{1}_Cbc_problemName"]
    pub fn Cbc_problemName(
        model: *mut Cbc_Model,
        maxNumberCharacters: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Number of nonzero elements in constraint matrix"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return number of non-zero entries in constraint matrix"]
    #[link_name = "\u{1}_Cbc_getNumElements"]
    pub fn Cbc_getNumElements(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Number of variables in the model"]
    #[doc = " @param model problem object"]
    #[doc = " @return number of columns (variables)"]
    #[link_name = "\u{1}_Cbc_getNumCols"]
    pub fn Cbc_getNumCols(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Number of integer variables in the model"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return number of integer variables in this model"]
    #[link_name = "\u{1}_Cbc_getNumIntegers"]
    pub fn Cbc_getNumIntegers(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Number of constraints in the model"]
    #[doc = " @param model problem object"]
    #[doc = " @return number of rows (constraints) in the model"]
    #[link_name = "\u{1}_Cbc_getNumRows"]
    pub fn Cbc_getNumRows(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Queries row name"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row index"]
    #[doc = " @param name string where row name will be stored"]
    #[doc = " @param string where row name will be stored"]
    #[link_name = "\u{1}_Cbc_getRowName"]
    pub fn Cbc_getRowName(
        model: *mut Cbc_Model,
        iRow: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLength: usize,
    );
}
extern "C" {
    #[doc = " Queries column name"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param iColumn column index"]
    #[doc = " @param name where name will be stored"]
    #[doc = " @param maxLength maximum length of name string"]
    #[link_name = "\u{1}_Cbc_getColName"]
    pub fn Cbc_getColName(
        model: *mut Cbc_Model,
        iColumn: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLength: usize,
    );
}
extern "C" {
    #[doc = " @brief Number of non-zero entries in a row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return number of non-zero entries in row"]
    #[link_name = "\u{1}_Cbc_getRowNz"]
    pub fn Cbc_getRowNz(model: *mut Cbc_Model, row: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Indices of variables that appear on a row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return vector with indexes of columns that appear on this row"]
    #[link_name = "\u{1}_Cbc_getRowIndices"]
    pub fn Cbc_getRowIndices(
        model: *mut Cbc_Model,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Coefficients of variables that appear on this row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return coefficients of variables that appear on this row"]
    #[link_name = "\u{1}_Cbc_getRowCoeffs"]
    pub fn Cbc_getRowCoeffs(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> *const f64;
}
extern "C" {
    #[doc = " @brief Number of non-zero entries in a column"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param col column index"]
    #[doc = " @return numbef of rows that this column appears"]
    #[link_name = "\u{1}_Cbc_getColNz"]
    pub fn Cbc_getColNz(model: *mut Cbc_Model, col: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Indices of rows that a column appears"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param col column index"]
    #[doc = " @return indices of rows that this column appears"]
    #[link_name = "\u{1}_Cbc_getColIndices"]
    pub fn Cbc_getColIndices(
        model: *mut Cbc_Model,
        col: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Coefficients that a column appear in rows"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param col column index"]
    #[doc = " @return coefficients of this column in rows"]
    #[link_name = "\u{1}_Cbc_getColCoeffs"]
    pub fn Cbc_getColCoeffs(model: *mut Cbc_Model, col: ::std::os::raw::c_int) -> *const f64;
}
extern "C" {
    #[doc = " @brief Right hand side of a row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return row right hand side"]
    #[link_name = "\u{1}_Cbc_getRowRHS"]
    pub fn Cbc_getRowRHS(model: *mut Cbc_Model, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief Sense a row"]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return row sense: E for =, L for <=, G for >= and R for ranged row"]
    #[link_name = "\u{1}_Cbc_getRowSense"]
    pub fn Cbc_getRowSense(
        model: *mut Cbc_Model,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Direction of optimization"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore)"]
    #[link_name = "\u{1}_Cbc_getObjSense"]
    pub fn Cbc_getObjSense(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " @brief Constraint lower bounds"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with lower bounds of constraints"]
    #[link_name = "\u{1}_Cbc_getRowLower"]
    pub fn Cbc_getRowLower(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Constraint upper bounds"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return constraint upper bounds"]
    #[link_name = "\u{1}_Cbc_getRowUpper"]
    pub fn Cbc_getRowUpper(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Objective vector"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with coefficients of variables in the objective function"]
    #[link_name = "\u{1}_Cbc_getObjCoefficients"]
    pub fn Cbc_getObjCoefficients(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Variable lower bounds"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with lower bounds of variables"]
    #[link_name = "\u{1}_Cbc_getColLower"]
    pub fn Cbc_getColLower(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Variable upper bounds"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with column upper bounds"]
    #[link_name = "\u{1}_Cbc_getColUpper"]
    pub fn Cbc_getColUpper(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Determine whether the ith variable is integer restricted"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param i variable index"]
    #[doc = " @return 1 if variable is integer, 0 otherwise"]
    #[link_name = "\u{1}_Cbc_isInteger"]
    pub fn Cbc_isInteger(model: *mut Cbc_Model, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read an mps file from the given filename"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param fileName file name"]
    #[link_name = "\u{1}_Cbc_readMps"]
    pub fn Cbc_readMps(
        model: *mut Cbc_Model,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Read an lp file from the given filename"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param fileName file name"]
    #[link_name = "\u{1}_Cbc_readLp"]
    pub fn Cbc_readLp(
        model: *mut Cbc_Model,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Write an mps file from the given filename"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param fileName file name"]
    #[link_name = "\u{1}_Cbc_writeMps"]
    pub fn Cbc_writeMps(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Write an lp file from the given filename"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param fileName file name"]
    #[link_name = "\u{1}_Cbc_writeLp"]
    pub fn Cbc_writeLp(model: *mut Cbc_Model, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Provide an initial feasible solution to accelerate branch-and-bound"]
    #[doc = "Note that feasibility of the solution is *not* verified."]
    #[link_name = "\u{1}_Cbc_setInitialSolution"]
    pub fn Cbc_setInitialSolution(model: *mut Cbc_Model, sol: *const f64);
}
extern "C" {
    #[doc = " \"Column start\" vector of constraint matrix. Same format as Cbc_loadProblem()"]
    #[link_name = "\u{1}_Cbc_getVectorStarts"]
    pub fn Cbc_getVectorStarts(model: *mut Cbc_Model) -> *const CoinBigIndex;
}
extern "C" {
    #[doc = " \"Row index\" vector of constraint matrix"]
    #[link_name = "\u{1}_Cbc_getIndices"]
    pub fn Cbc_getIndices(model: *mut Cbc_Model) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Coefficient vector of constraint matrix"]
    #[link_name = "\u{1}_Cbc_getElements"]
    pub fn Cbc_getElements(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " Maximum lenght of a row or column name"]
    #[link_name = "\u{1}_Cbc_maxNameLength"]
    pub fn Cbc_maxNameLength(model: *mut Cbc_Model) -> usize;
}
extern "C" {
    #[doc = " Print the model"]
    #[link_name = "\u{1}_Cbc_printModel"]
    pub fn Cbc_printModel(model: *mut Cbc_Model, argPrefix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set parameter \"name\" to value \"value\". Note that this"]
    #[doc = " translates directly to using \"-name value\" as a"]
    #[doc = " command-line argument to Cbc."]
    #[link_name = "\u{1}_Cbc_setParameter"]
    pub fn Cbc_setParameter(
        model: *mut Cbc_Model,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " returns the allowable gap"]
    #[link_name = "\u{1}_Cbc_getAllowableGap"]
    pub fn Cbc_getAllowableGap(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " sets the allowable gap"]
    #[link_name = "\u{1}_Cbc_setAllowableGap"]
    pub fn Cbc_setAllowableGap(model: *mut Cbc_Model, allowedGap: f64);
}
extern "C" {
    #[doc = " returns the allowable fraction gap"]
    #[link_name = "\u{1}_Cbc_getAllowableFractionGap"]
    pub fn Cbc_getAllowableFractionGap(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " sets the allowable fraction gap"]
    #[link_name = "\u{1}_Cbc_setAllowableFractionGap"]
    pub fn Cbc_setAllowableFractionGap(model: *mut Cbc_Model, allowedFracionGap: f64);
}
extern "C" {
    #[doc = " returns the allowable percentage gap"]
    #[link_name = "\u{1}_Cbc_getAllowablePercentageGap"]
    pub fn Cbc_getAllowablePercentageGap(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " sets the allowable percentage gap"]
    #[link_name = "\u{1}_Cbc_setAllowablePercentageGap"]
    pub fn Cbc_setAllowablePercentageGap(model: *mut Cbc_Model, allowedPercentageGap: f64);
}
extern "C" {
    #[doc = " returns the time limit for the search process"]
    #[link_name = "\u{1}_Cbc_getMaximumSeconds"]
    pub fn Cbc_getMaximumSeconds(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " sets the time limit for the search process"]
    #[link_name = "\u{1}_Cbc_setMaximumSeconds"]
    pub fn Cbc_setMaximumSeconds(model: *mut Cbc_Model, maxSeconds: f64);
}
extern "C" {
    #[doc = " returns the maximum number of nodes that can be explored in the search tree"]
    #[link_name = "\u{1}_Cbc_getMaximumNodes"]
    pub fn Cbc_getMaximumNodes(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the maximum number of nodes that can be explored in the search tree"]
    #[link_name = "\u{1}_Cbc_setMaximumNodes"]
    pub fn Cbc_setMaximumNodes(model: *mut Cbc_Model, maxNodes: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " returns solution limit for the search process"]
    #[link_name = "\u{1}_Cbc_getMaximumSolutions"]
    pub fn Cbc_getMaximumSolutions(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets a solution limit as a stopping criterion"]
    #[link_name = "\u{1}_Cbc_setMaximumSolutions"]
    pub fn Cbc_setMaximumSolutions(model: *mut Cbc_Model, maxSolutions: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " returns the current log leven"]
    #[link_name = "\u{1}_Cbc_getLogLevel"]
    pub fn Cbc_getLogLevel(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " sets the log level"]
    #[link_name = "\u{1}_Cbc_setLogLevel"]
    pub fn Cbc_setLogLevel(model: *mut Cbc_Model, logLevel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " returns the cutoff"]
    #[link_name = "\u{1}_Cbc_getCutoff"]
    pub fn Cbc_getCutoff(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " sets the cutoff"]
    #[link_name = "\u{1}_Cbc_setCutoff"]
    pub fn Cbc_setCutoff(model: *mut Cbc_Model, cutoff: f64);
}
extern "C" {
    #[doc = " Pass in Callback function."]
    #[doc = "Message numbers up to 1000000 are Clp, Coin ones have 1000000 added"]
    #[link_name = "\u{1}_Cbc_registerCallBack"]
    pub fn Cbc_registerCallBack(model: *mut Cbc_Model, userCallBack: cbc_callback);
}
extern "C" {
    #[doc = " Unset Callback function"]
    #[link_name = "\u{1}_Cbc_clearCallBack"]
    pub fn Cbc_clearCallBack(model: *mut Cbc_Model);
}
extern "C" {
    #[link_name = "\u{1}_Cbc_addCutCallback"]
    pub fn Cbc_addCutCallback(
        model: *mut Cbc_Model,
        cutcb: cbc_cut_callback,
        name: *const ::std::os::raw::c_char,
        appData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_Cbc_solve"]
    pub fn Cbc_solve(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Best feasible solution vector"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with best solution found"]
    #[link_name = "\u{1}_Cbc_getColSolution"]
    pub fn Cbc_getColSolution(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " @brief Best known bound on the optimal objective value"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return best possible cost (lower bound)"]
    #[link_name = "\u{1}_Cbc_getBestPossibleObjValue"]
    pub fn Cbc_getBestPossibleObjValue(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " @brief Best integer feasible solution"]
    #[doc = ""]
    #[doc = " Best integer feasible solution or NULL if no integer feas sol found"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return vector with the best solution found or NULL if no feasible solution was found"]
    #[link_name = "\u{1}_Cbc_bestSolution"]
    pub fn Cbc_bestSolution(model: *mut Cbc_Model) -> *mut f64;
}
extern "C" {
    #[doc = " @brief number of integer feasible solution saved"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return number of saved solutions"]
    #[link_name = "\u{1}_Cbc_numberSavedSolutions"]
    pub fn Cbc_numberSavedSolutions(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Vector with the i-th saved solution"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param whichSol index of the solution to be retrieved"]
    #[doc = " @return vector with integer feasible solution"]
    #[link_name = "\u{1}_Cbc_savedSolution"]
    pub fn Cbc_savedSolution(model: *mut Cbc_Model, whichSol: ::std::os::raw::c_int) -> *const f64;
}
extern "C" {
    #[doc = " @brief Cost of the whichSol solution"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param whichSol solution index"]
    #[doc = " @return solution cost"]
    #[link_name = "\u{1}_Cbc_savedSolutionObj"]
    pub fn Cbc_savedSolutionObj(model: *mut Cbc_Model, whichSol: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief Queries vector of reduced costs"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return reduced cost vector"]
    #[link_name = "\u{1}_Cbc_getReducedCost"]
    pub fn Cbc_getReducedCost(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " If optimization was abandoned due to numerical difficulties"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return 1 if numerical difficulties interrupted the optimization, 0 otherwise"]
    #[link_name = "\u{1}_Cbc_isAbandoned"]
    pub fn Cbc_isAbandoned(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief If the optimal solution was found"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return 1 if optimal solution was found, 0 otherwise"]
    #[link_name = "\u{1}_Cbc_isProvenOptimal"]
    pub fn Cbc_isProvenOptimal(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief If infeasibility was proven"]
    #[doc = ""]
    #[doc = " If model is infeasible, please note that infeasibility can also be declared"]
    #[doc = " if cutoff is informed and no solution better than the cutoff exists."]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return 1 if model is infeasible, 0 otherwise"]
    #[link_name = "\u{1}_Cbc_isProvenInfeasible"]
    pub fn Cbc_isProvenInfeasible(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Is continuous model unbounded ?"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return 1 if model is unbounded, 0 otherwise"]
    #[link_name = "\u{1}_Cbc_isContinuousUnbounded"]
    pub fn Cbc_isContinuousUnbounded(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Objective value of best feasible solution"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return cost of the best solution found"]
    #[link_name = "\u{1}_Cbc_getObjValue"]
    pub fn Cbc_getObjValue(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " @brief Final optimization status"]
    #[doc = ""]
    #[doc = " Returns the optimization status. For more info check function"]
    #[doc = " isProvenOptimal, isProvenInfeasible, etc. Check also secondary status."]
    #[doc = " Possible status are:"]
    #[doc = ""]
    #[doc = " -1 before branchAndBound"]
    #[doc = " 0 finished - check isProvenOptimal or isProvenInfeasible to see if solution found (or check value of best solution)"]
    #[doc = " 1 stopped - on maxnodes, maxsols, maxtime"]
    #[doc = " 2 execution abandoned due to numerical dificulties"]
    #[doc = " 5 user programmed interruption"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @return problem status"]
    #[link_name = "\u{1}_Cbc_status"]
    pub fn Cbc_status(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Secondary status of problem"]
    #[doc = ""]
    #[doc = " Returns additional information regarding the optimization status"]
    #[doc = ""]
    #[doc = " -1 unset (status_ will also be -1)"]
    #[doc = "  0 search completed with solution"]
    #[doc = "  1 linear relaxation not feasible (or worse than cutoff)"]
    #[doc = "  2 stopped on gap"]
    #[doc = "  3 stopped on nodes"]
    #[doc = "  4 stopped on time"]
    #[doc = "  5 stopped on user event"]
    #[doc = "  6 stopped on solutions"]
    #[doc = "  7 linear relaxation unbounded"]
    #[doc = "  8 stopped on iteration limit"]
    #[doc = ""]
    #[doc = "  @model problem object"]
    #[doc = "  @return optimization status"]
    #[link_name = "\u{1}_Cbc_secondaryStatus"]
    pub fn Cbc_secondaryStatus(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sum of primal infeasibilities"]
    #[link_name = "\u{1}_Cbc_sumPrimalInfeasibilities"]
    pub fn Cbc_sumPrimalInfeasibilities(model: *mut Cbc_Model) -> f64;
}
extern "C" {
    #[doc = " Number of primal infeasibilities"]
    #[link_name = "\u{1}_Cbc_numberPrimalInfeasibilities"]
    pub fn Cbc_numberPrimalInfeasibilities(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Just check solution (for external use) - sets sum of"]
    #[doc = "infeasibilities etc"]
    #[link_name = "\u{1}_Cbc_checkSolution"]
    pub fn Cbc_checkSolution(model: *mut Cbc_Model);
}
extern "C" {
    #[doc = " Number of iterations"]
    #[link_name = "\u{1}_Cbc_getIterationCount"]
    pub fn Cbc_getIterationCount(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Node limit reached?"]
    #[link_name = "\u{1}_Cbc_isNodeLimitReached"]
    pub fn Cbc_isNodeLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Time limit reached?"]
    #[link_name = "\u{1}_Cbc_isSecondsLimitReached"]
    pub fn Cbc_isSecondsLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Solution limit reached?"]
    #[link_name = "\u{1}_Cbc_isSolutionLimitReached"]
    pub fn Cbc_isSolutionLimitReached(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Are there numerical difficulties (for initialSolve) ?"]
    #[link_name = "\u{1}_Cbc_isInitialSolveAbandoned"]
    pub fn Cbc_isInitialSolveAbandoned(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is optimality proven (for initialSolve) ?"]
    #[link_name = "\u{1}_Cbc_isInitialSolveProvenOptimal"]
    pub fn Cbc_isInitialSolveProvenOptimal(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is primal infeasiblity proven (for initialSolve) ?"]
    #[link_name = "\u{1}_Cbc_isInitialSolveProvenPrimalInfeasible"]
    pub fn Cbc_isInitialSolveProvenPrimalInfeasible(model: *mut Cbc_Model)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \"row\" solution"]
    #[doc = "  This is the vector A*x, where A is the constraint matrix"]
    #[doc = "  and x is the current solution."]
    #[link_name = "\u{1}_Cbc_getRowActivity"]
    pub fn Cbc_getRowActivity(model: *mut Cbc_Model) -> *const f64;
}
extern "C" {
    #[doc = " Number of nodes explored in B&B tree"]
    #[link_name = "\u{1}_Cbc_getNodeCount"]
    pub fn Cbc_getNodeCount(model: *mut Cbc_Model) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print the solution"]
    #[link_name = "\u{1}_Cbc_printSolution"]
    pub fn Cbc_printSolution(model: *mut Cbc_Model);
}
extern "C" {
    #[doc = " @brief Returns number of cols in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getNumCols"]
    pub fn Osi_getNumCols(osi: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns column name in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getColName"]
    pub fn Osi_getColName(
        osi: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
        maxLen: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns column lower bounds in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getColLower"]
    pub fn Osi_getColLower(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
extern "C" {
    #[doc = " @brief Returns column upper bounds in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getColUpper"]
    pub fn Osi_getColUpper(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
extern "C" {
    #[doc = " @brief Returns integrality information for columns in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_isInteger"]
    pub fn Osi_isInteger(
        osi: *mut ::std::os::raw::c_void,
        col: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns number of rows in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getNumRows"]
    pub fn Osi_getNumRows(osi: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Osi_getRowNz"]
    pub fn Osi_getRowNz(
        osi: *mut ::std::os::raw::c_void,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Indices of variables that appear on a row"]
    #[link_name = "\u{1}_Osi_getRowIndices"]
    pub fn Osi_getRowIndices(
        osi: *mut ::std::os::raw::c_void,
        row: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Coefficients of variables that appear on this row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return coefficients of variables that appear on this row"]
    #[link_name = "\u{1}_Osi_getRowCoeffs"]
    pub fn Osi_getRowCoeffs(
        osi: *mut ::std::os::raw::c_void,
        row: ::std::os::raw::c_int,
    ) -> *const f64;
}
extern "C" {
    #[doc = " @brief Right hand side of a row"]
    #[doc = ""]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return row right hand side"]
    #[link_name = "\u{1}_Osi_getRowRHS"]
    pub fn Osi_getRowRHS(osi: *mut ::std::os::raw::c_void, row: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief Sense a row"]
    #[doc = " @param model problem object"]
    #[doc = " @param row row index"]
    #[doc = " @return row sense: E for =, L for <=, G for >= and R for ranged row"]
    #[link_name = "\u{1}_Osi_getRowSense"]
    pub fn Osi_getRowSense(
        osi: *mut ::std::os::raw::c_void,
        row: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns solution vector in OsiSolverInterface object"]
    #[link_name = "\u{1}_Osi_getColSolution"]
    pub fn Osi_getColSolution(osi: *mut ::std::os::raw::c_void) -> *const f64;
}
extern "C" {
    #[doc = " adds a row cut (used in callback)"]
    #[link_name = "\u{1}_OsiCuts_addRowCut"]
    pub fn OsiCuts_addRowCut(
        osiCuts: *mut ::std::os::raw::c_void,
        nz: ::std::os::raw::c_int,
        idx: *const ::std::os::raw::c_int,
        coef: *const f64,
        sense: ::std::os::raw::c_char,
        rhs: f64,
    );
}
